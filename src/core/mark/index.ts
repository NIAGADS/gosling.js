import { GeminiTrackModel } from '../gemini-track-model';
import { drawPoint } from './point';
import { drawLine } from './line';
import { drawBar } from './bar';
import { drawArea } from './area';
import { drawRect } from './rect';
import { ChannelTypes } from '../gemini.schema';
import { drawTriangle } from './triangle';
import { drawText } from './text';
import { drawRule } from './rule';
import { drawLink } from './link';
import { drawGrid } from './grid';
import { drawChartOutlines } from './chart-outline';
import { drawColorLegend, drawYLegend } from './legend';

/**
 * Visual channels currently supported for visual encoding.
 */
export const SUPPORTED_CHANNELS: (keyof typeof ChannelTypes)[] = [
    'x',
    'xe',
    'x1',
    'x1e',

    'y',
    'ye',
    'y1',
    'y1e',

    'color',
    'size',
    'row',
    'stroke',
    'strokeWidth',
    'opacity',
    'text',
    'background'
    // ...
];

export const RESOLUTION = 4;

/**
 * Draw a track based on the track specification in a Gemini grammar.
 */
export function drawMark(HGC: any, trackInfo: any, tile: any, tm: GeminiTrackModel) {
    if (!HGC || !trackInfo || !tile) {
        // We did not receive parameters correctly.
        return;
    }

    if (tm.spec().mark === 'rect-brush') {
        // We do not draw brush. Instead, higlass do.
        return;
    }

    // Replace the scale of a genomic axis with the one that is generated by the HiGlass data fetcher.
    ['x', 'x1', 'x1e', 'xe'].forEach((d: any) => {
        // const c = tm.spec()[d as keyof typeof ChannelTypes];
        // if(IsChannelDeep(c) && c.type === 'genomic') {
        tm.setChannelScale(d, trackInfo._xScale);
        // }
    });

    /* before-embellishment */
    drawGrid(HGC, trackInfo, tile, tm);
    drawChartOutlines(HGC, trackInfo, tm);

    /* spec */
    switch (tm.spec().mark) {
        case 'point':
            drawPoint(HGC, trackInfo, tile, tm);
            break;
        case 'bar':
            drawBar(HGC, trackInfo, tile, tm);
            break;
        case 'line':
            drawLine(HGC, trackInfo, tile, tm);
            break;
        case 'area':
            drawArea(HGC, trackInfo, tile, tm);
            break;
        case 'rect':
            drawRect(HGC, trackInfo, tile, tm);
            break;
        case 'triangle-l':
        case 'triangle-r':
        case 'triangle-d':
            drawTriangle(HGC, trackInfo, tile, tm);
            break;
        case 'text':
            drawText(HGC, trackInfo, tile, tm);
            break;
        case 'rule':
            drawRule(HGC, trackInfo, tile, tm);
            break;
        case 'link':
            drawLink(HGC, trackInfo, tile, tm);
            break;
        default:
            console.warn('Unsupported mark type');
            break;
    }

    /* after-embellishment */
    drawColorLegend(HGC, trackInfo, tile, tm);
    drawYLegend(HGC, trackInfo, tile, tm);

    if (!tile.rowScale || !tile.spriteInfos) {
        console.warn('Information for resaling tiles is not properly generated after drawing a track');
    }
}
