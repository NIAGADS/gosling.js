import { GeminiTrackModel } from '../gemini-track-model';
import { drawCircularRect } from './c-rect';

/**
 * Draw a track based on the track specification in a Gemini grammar.
 */
export function drawCircularMark(HGC: any, trackInfo: any, tile: any, tm: GeminiTrackModel) {
    if (!HGC || !trackInfo || !tile) {
        // We did not receive parameters correctly.
        return;
    }

    if (tm.spec().mark === 'rect-brush') {
        // We do not draw brush. Instead, higlass do.
        return;
    }

    // Replace the scale of a genomic axis with the one that is generated by the HiGlass data fetcher.
    ['x', 'x1', 'x1e', 'xe'].forEach((d: any) => {
        tm.setChannelScale(d, trackInfo._xScale);
    });

    /* embellishment */
    // ...

    /* spec */
    switch (tm.spec().mark) {
        case 'point':
            break;
        case 'bar':
            break;
        case 'line':
            break;
        case 'area':
            break;
        case 'rect':
            drawCircularRect(HGC, trackInfo, tile, tm);
            break;
        case 'triangle-l':
        case 'triangle-r':
        case 'triangle-d':
            break;
        case 'text':
            break;
        case 'rule':
            break;
        case 'link':
            break;
        default:
            console.warn('Unsupported mark type');
            break;
    }

    if (!tile.rowScale || !tile.spriteInfos) {
        console.warn('Information for resaling tiles is not properly generated after drawing a track');
    }
}
